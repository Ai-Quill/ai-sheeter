import { NextResponse } from 'next/server';
import { decryptApiKey } from '@/utils/encryption';
import OpenAI from 'openai';
import { GoogleGenerativeAI } from "@google/generative-ai";

export async function POST(req: Request): Promise<Response> {
  const { model, prompt, userEmail, encryptedApiKey } = await req.json();

  if (!model || !prompt || !userEmail || !encryptedApiKey) {
    return NextResponse.json({ error: 'Missing required parameters' }, { status: 400 });
  }

  try {
    const decryptedApiKey = decryptApiKey(encryptedApiKey);

    if (!decryptedApiKey) {
      return NextResponse.json({ error: 'Invalid API key' }, { status: 401 });
    }

    let imageUrl: string;

    switch (model) {
      case 'DALLE':
        const openai = new OpenAI({ apiKey: decryptedApiKey });
        const dalleResponse = await openai.images.generate({
          model: "dall-e-3",
          prompt: prompt,
          n: 1,
          size: "1024x1024",
        });
        imageUrl = dalleResponse.data[0].url!;
        break;

      case 'GEMINI':
        const genAI = new GoogleGenerativeAI(decryptedApiKey);
        const geminiModel = genAI.getGenerativeModel({ model: "gemini-pro-vision" });
        const geminiResult = await geminiModel.generateContent([prompt]);
        const geminiResponse = await geminiResult.response;
        if (!geminiResponse.candidates || geminiResponse.candidates.length === 0) {
          throw new Error('No image generated by Gemini');
        }
        const imageBlob = geminiResponse.candidates[0].content.parts[0].inlineData?.data;
        if (!imageBlob) {
          throw new Error('Failed to generate image with Gemini');
        }
        // Here you would typically upload the imageBlob to a storage service and get a URL
        // For this example, we'll just return a placeholder
        imageUrl = "https://placeholder.com/gemini-generated-image.jpg";
        break;

      default:
        return NextResponse.json({ error: 'Unsupported model' }, { status: 400 });
    }

    // Log credit usage (you'll need to implement this based on your pricing model)
    // await logCreditUsage(userEmail, model, 1);

    return NextResponse.json({ imageUrl });
  } catch (error: unknown) {
    console.error('Error generating image:', error);
    return NextResponse.json({ error: 'Failed to generate image: ' + (error instanceof Error ? error.message : String(error)) }, { status: 500 });
  }
}
