import { NextResponse } from 'next/server';
import { decryptApiKey } from '@/utils/encryption';
import OpenAI from 'openai';
import { GoogleGenerativeAI } from "@google/generative-ai";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { v4 as uuidv4 } from 'uuid';
import { supabaseAdmin } from '@/lib/supabase';

// Initialize S3 client
const s3Client = new S3Client({
  region: process.env.AWS_REGION!,
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
  },
});

const S3_BUCKET_NAME = process.env.S3_BUCKET_NAME;

async function uploadToS3(imageBuffer: Buffer, userId: string, fileName: string): Promise<string> {
  if (!S3_BUCKET_NAME) {
    throw new Error('S3_BUCKET_NAME is not defined in environment variables');
  }

  const key = `users/${userId}/${fileName}`;
  const uploadParams = {
    Bucket: S3_BUCKET_NAME,
    Key: key,
    Body: imageBuffer,
    ContentType: 'image/png',
    ACL: 'public-read' as const, // Type assertion to 'public-read'
  };

  try {
    await s3Client.send(new PutObjectCommand(uploadParams));
    return `https://${S3_BUCKET_NAME}.s3.amazonaws.com/${key}`;
  } catch (error) {
    console.error('Error uploading to S3:', error);
    throw new Error('Failed to upload image to S3');
  }
}

export async function POST(req: Request): Promise<Response> {
  try {
    const { model, prompt, userId, encryptedApiKey } = await req.json();

    if (!model || !prompt || !userId || !encryptedApiKey) {
      return NextResponse.json({ error: 'Missing required parameters' }, { status: 400 });
    }

    const decryptedApiKey = decryptApiKey(encryptedApiKey);

    if (!decryptedApiKey) {
      return NextResponse.json({ error: 'Invalid API key' }, { status: 401 });
    }

    let imageBuffer: Buffer;

    switch (model) {
      case 'DALLE':
        const openai = new OpenAI({ apiKey: decryptedApiKey });
        const dalleResponse = await openai.images.generate({
          model: "dall-e-3",
          prompt: prompt,
          n: 1,
          size: "1024x1024",
          response_format: "b64_json",
        });
        imageBuffer = Buffer.from(dalleResponse.data[0].b64_json!, 'base64');
        break;

      case 'GEMINI':
        const genAI = new GoogleGenerativeAI(decryptedApiKey);
        const geminiModel = genAI.getGenerativeModel({ model: "gemini-pro-vision" });
        const geminiResult = await geminiModel.generateContent([prompt]);
        const geminiResponse = await geminiResult.response;
        if (!geminiResponse.candidates || geminiResponse.candidates.length === 0) {
          throw new Error('No image generated by Gemini');
        }
        const imageBlob = geminiResponse.candidates[0].content.parts[0].inlineData?.data;
        if (!imageBlob) {
          throw new Error('Failed to generate image with Gemini');
        }
        imageBuffer = Buffer.from(imageBlob, 'base64');
        break;

      default:
        return NextResponse.json({ error: 'Unsupported model' }, { status: 400 });
    }

    const fileName = `${uuidv4()}.png`;
    const imageUrl = await uploadToS3(imageBuffer, userId, fileName);

    const { error } = await supabaseAdmin
      .from('generated_images')
      .insert({ url: imageUrl, user_id: userId, model: model });

    if (error) throw error;

    return NextResponse.json({ imageUrl });
  } catch (error: unknown) {
    console.error('Error generating image:', error);
    return NextResponse.json({ error: 'Failed to generate image: ' + (error instanceof Error ? error.message : String(error)) }, { status: 500 });
  }
}
